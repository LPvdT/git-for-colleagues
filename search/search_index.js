var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Introduction","text":"<p>This is a simple hands-on guide on the basic concepts of SCM (Source Code Management) in Git.</p> <p>Git, and platforms like GitHub, are not the same thing - even though a lot of people starting out in the scene think so. GitHub is a cloud-based hosting service that provides additional functionality to help you better manage repositories. Git is the version control system that powers it.</p> <p>The goal is to familiarize you with the concepts, workflows and commands that should suffice to comfortably get you going in the vast majority of the projects. If you would want to manage complex public repositories, with a lot of bells and whistles involved, you may have to do some additional reading. </p> <p>On a final note, there are sometimes ways to do things similarly in Git, by using commands combined with a load of arguments. The approaches I aim to demonstrate here, are meant to be the easy to wrap your head around, even if that means there may be a little bit more commands to run.</p>"},{"location":"index.html#how-long-does-this-take","title":"How long does this take?","text":"<p>Reading through the whole guide will take you approximately 45 minutes to one hour. Of course, if you are following along, and trying stuff out in the command line in your own repository, it may take a little longer.</p>"},{"location":"branches/index.html","title":"Branches","text":"<p>In Git, a branch is simply a pointer to a specific commit in your repository. Branches are used when you want to, e.g., add a new feature to your project, or implement a hotfix, while keeping your reference point (the commit or branch that your new branch has been created from) intact.</p> <p>When creating a branch, you more or less tell Git: \"Give me a separate starting point, including all the work from this commit and all the commits before it.\"</p>"},{"location":"branches/index.html#the-main-branch","title":"The <code>main</code> branch","text":"<p>After initialising a repository, you always start out with a single branch called <code>main</code>. </p> Why you should not directly commit into the <code>main</code> branch <p>For reasons, which I will get into later, it is extremely bad practice (and very frowned upon in the open source community) to actively commit into your <code>main</code> branch. </p> <p>This branch should generally be your release version of the project only - and should therefore always be clean and bug-free. Unjustifiably committing changes into this branch could heavily disrupt your project end-user's experience.</p> <p>It is best practice to (at least) have a separate <code>development</code> branch, in which you make your changes, which you subsequently merge into your <code>main</code> branch, once new features have been properly completed and tested.</p> <p>Note</p> <p>The initial branch of the Git repository could also be named <code>master</code>. This is usually the case in older Git versions. The change to the default naming convention <code>main</code> has occurred after the general uproar around the terms master/slave.</p>"},{"location":"branches/cherry_picking.html","title":"Cherry picking","text":"<p>It may happen that you have accidentally committed a change into the wrong branch or that, in hindsight, some prior commits actually make more sense in another branch. This is where cherry picking comes in.</p> <p>Where <code>git rebase</code> appends all commits of one branch onto another branch, <code>git cherry-pick</code> lets you choose which specific comments you want to 'copy' to another branch.</p> <p>Info</p> <p>While <code>git rebase</code> is destructive, <code>git cherry-pick</code> is not. After cherry-picking the commits you want, the original branch - and commits - still exist exactly as they were.</p>"},{"location":"branches/cherry_picking.html#example-git-cherry-pick","title":"Example: <code>git cherry-pick</code>","text":"<p>The visualisation below is more or less the same as the merging example in the previous section. However, this time, we were accidentally checked out in the <code>main</code> branch when we committed the commit with hash damn.</p> <pre><code>gitGraph\n  commit id: \"main_1\"\n  commit id: \"main_2\"\n  branch development\n  commit id: \"dev_1\"\n  checkout main\n  commit type: HIGHLIGHT id: \"damn\"\n  checkout development\n  commit id: \"dev_2\"\n  commit id: \"dev_3\"\n  checkout main</code></pre> <p>In order to fix this, we will use <code>git cherry-pick</code>:</p> <pre><code># Ensure the branch we want to cherry pick the comment to is checked out\ngit switch development\n\n# Cherry pick the commit we want to move to 'development'\ngit cherry-pick damn\n</code></pre> <pre><code>gitGraph\n  commit id: \"main_1\"\n  commit id: \"main_2\"\n  branch development\n  commit id: \"dev_1\"\n  checkout main\n  commit type: HIGHLIGHT id: \"damn\"\n  checkout development\n  commit id: \"dev_2\"\n  commit id: \"dev_3\"\n  cherry-pick id: \"damn\"\n  checkout main</code></pre> <p>The commit has now been successfully copied to the <code>development</code> branch. However, note that it also still exists on the <code>main</code> branch. This is the nature of Git: it essentially attempts to preserve as much history as possible.</p> <p>However, if you do not want this commit in <code>main</code>, it is possible to remove it by entirely rewriting history. I'll discuss this in the next section.</p>"},{"location":"branches/creating_switching.html","title":"Managing branches","text":""},{"location":"branches/creating_switching.html#creating-a-new-branch","title":"Creating a new branch","text":"<p>In order to create a new branch at your current location, you can use the <code>git branch</code> command. You can also create a branch at a different location. Refer to the examples below:</p> <pre><code># Create the branch 'development' at current location (HEAD)\ngit branch development\n\n# Create the branch 'bugfix' at commit with hash 'ab245'\ngit branch bugfix ab245\n</code></pre> <p>When subsequently calling <code>git branch</code> without an argument, Git shows all your branches, along with the active one:</p> <pre><code>  development\n* main\n</code></pre>"},{"location":"branches/creating_switching.html#switching-to-a-different-branch","title":"Switching to a different branch","text":"<p>In order to start writing commits into the new <code>development</code> branch, we first need to switch to it. In Git this is called 'checking out' and is accomplished using the <code>git switch</code> command. You can check out commits, as well as branches. But to keep things simple, we will stick to branches for now. </p> <pre><code># Checkout (i.e. switch to) the 'development' branch\ngit switch development\n\n# Or using `checkout`\ngit checkout branch\n</code></pre> <code>git switch</code> or <code>git checkout</code>? <p>A lot of online resources will point you towards the <code>git checkout</code> command. This still works fine in most cases. There is, however, a lot going on under the hood that makes the two commands perform differently from each other. </p> <p>Stick to <code>git switch</code>, as it is the recommended approach in newer Git versions, unless you need specific options that only <code>git checkout</code> provides.</p>"},{"location":"branches/creating_switching.html#example","title":"Example","text":"<p>Below is a simple visualisation to demonstrate this process:</p> <ol> <li><code>git init</code><ul> <li>A new repository is made. <code>main</code> is the default branch.</li> </ul> </li> <li>Two commits are made on the <code>main</code> branch.<ul> <li>Therefore, twice, a file has been added/modified; staged with <code>git add</code> and then committed with <code>git commit</code>.</li> </ul> </li> <li>A new branch called <code>development</code> is made with <code>git branch development</code>.</li> <li>The <code>development</code> branch is switched to with <code>git switch development</code>.</li> <li>Three commits are made on the <code>development branch</code>.<ul> <li>Therefore, three times, a file has been added/modified; staged with <code>git add</code> and then committed with <code>git commit</code>.</li> </ul> </li> </ol> <pre><code>gitGraph\n  commit id: \"main_1\"\n  commit id: \"main_2\"\n  branch development\n  checkout development\n  commit id: \"dev_1\"\n  commit id: \"dev_2\"\n  commit id: \"dev_3\"</code></pre> <p>Tip</p> <p>To create a new branch, and immediately check it out, you can use the following shorthand: <code>git checkout -b &lt;new_branch_name&gt;</code>:</p> <pre><code># Create the branch 'development' and immediately check it out\ngit checkout -b development\n</code></pre> <p>To forcibly move a branch around, you can use: <code>git branch -f &lt;branch_name&gt; &lt;new_location&gt;</code>:</p> <pre><code># Set the current state of branch 'development' to be commit with hash 'td364' instead of HEAD\ngit branch -f development td364\n</code></pre>"},{"location":"branches/merge_rebase.html","title":"Merging and rebasing","text":""},{"location":"branches/merge_rebase.html#merging","title":"Merging","text":"<p>Merging is the process of combining the commits of one branch into another. It pulls in all changes since the time the branch's history diverged from the current branch.</p> <p>For instance, if you have finished work on a branch <code>feature/preprocessing</code>, and want to include these changes in your <code>development</code> branch, you would merge the former into the latter.</p>"},{"location":"branches/merge_rebase.html#example-git-merge","title":"Example: <code>git merge</code>","text":"<p>In the visualisation below, we are satisfied with the work on the <code>development</code> branch and subsequently want to merge it into our <code>main</code> branch.</p> <pre><code># Ensure we are checked out in the branch we want to merge into\ngit switch main\n\n# Then merge the 'development' branch into the 'main' branch\ngit merge development\n</code></pre> <pre><code>gitGraph\n    commit id: \"main_1\"\n    commit id: \"main_2\"\n    branch development\n    checkout development\n    commit id: \"dev_1\"\n    commit id: \"dev_2\"\n    commit id: \"dev_3\"\n    checkout main\n    merge development</code></pre>"},{"location":"branches/merge_rebase.html#rebasing","title":"Rebasing","text":"<p>Rebasing is kind of similar to merging. When rebasing, you move and combine the commits of another branch and append them to the current branch.</p>"},{"location":"branches/merge_rebase.html#example-git-rebase","title":"Example: <code>git rebase</code>","text":"<p>In the visualisation below, we are once again satisfied with the work on the <code>development</code> branch and subsequently want to rebase it onto our <code>main</code> branch.</p> <p>As Mermaid graphs do not support rebase as in its syntax, I have constructed it in a poor man's way below. The highlighted commits on <code>main</code> prefixed with <code>r_</code> denote the commits rebased onto the <code>main</code> branch from the <code>development</code> branch.</p> <pre><code># Ensure we are checked out in the branch we want to rebase onto another branch\ngit switch development\n\n# Then rebase the active branch onto the 'main' branch\ngit rebase main\n\n# Then advance (fast-forward) the main branch to the newest commit\ngit switch main\ngit rebase feature\n</code></pre> <pre><code>gitGraph\n    commit id: \"main_1\"\n    commit id: \"main_2\"\n    branch development\n    checkout development\n    commit id: \"dev_1\"\n    commit id: \"dev_2\"\n    commit id: \"dev_3\"\n    checkout main\n    commit id: \"r_dev_1\" type: HIGHLIGHT\n    commit id: \"r_dev_2\" type: HIGHLIGHT\n    commit id: \"r_dev_3\" type: HIGHLIGHT</code></pre> When to use <code>git rebase</code> over <code>git merge</code>? <p><code>git rebase</code> is destructive</p> <p>First and foremost, <code>rebase</code> has some inherent dangers for beginners. The short version is that, among other things, <code>rebase</code> is destructive; which can be catastrophic in a DevOps workflow, as you cannot reverse the changes, whereas <code>merge</code> is not. Therefore, it is safer for beginners to stick to <code>merge</code>. Also, as a general rule of thumb, never <code>rebase</code> when working in public repositories with other contributors.</p> <p><code>git rebase</code> can be clear- and clean-looking</p> <p>Having said that, using <code>rebase</code> over <code>merge</code> allows for a much cleaner, and linear, project history. This, in turn, makes commands like <code>git log</code> and <code>git bisect</code> easier to navigate with. Furthermore, one of the best features of <code>rebase</code> is the <code>i</code> flag, which triggers an interactive rebase. This allows the developer to clean up the commit history while rebasing. Learn more about it here.</p>"},{"location":"commits/index.html","title":"Commits","text":"<p>Commits are basically checkpoints, wherein Git records the changes within files and folder with respect to the previous state.</p> <ul> <li>For newly committed files, that previous were not checked, Git simply starts tracking them.</li> <li>For files that have been committed previously, and are committed again with changes, Git will keep track of the changes.</li> </ul>"},{"location":"commits/committing.html","title":"Committing","text":"<p>To commit the files, which have been put in the staging area in the previous section, we will use the <code>git commit</code> command.</p> <pre><code># Commit the current changes in the staging area\ngit commit -m \"Add: New Markdown files for the commits section\"\n</code></pre> <p>Upon running this, you will get a message like the following:</p> <pre><code>[development 0db34a8] Add: New Markdown files for the commits section\n2 files changed, 8 insertions(+)\ncreate mode 100644 docs/commits/committing.md\ncreate mode 100644 docs/commits/staging.md\n</code></pre> <p>Info</p> <p>I have now created a commit (i.e. checkpoint) for these two files in their current state. I have included them both in a single commit, because that makes sense here; both files are part of the content section about commits in my project.</p> <p>If I were to change them later on, and accidentally break something, I can always revert the state of the files to this commit (i.e. this checkpoint).</p>"},{"location":"commits/difference.html","title":"Inspecting differences","text":"<p>As said previously, committing the same file again, after changes have been made to it, makes Git track the changes.</p> <p>In order to show the differences in a file(s), relative to previous versions. One of the easiest, and most visually clear way to do this, is by using the Git Graph extension in VSCode.</p>"},{"location":"commits/difference.html#git-graph","title":"Git Graph","text":"<p>Commit history:</p> <p></p> <p>Changes in specific file with respect to previous commit:</p> <p></p>"},{"location":"commits/difference.html#git-cli","title":"Git CLI","text":"<p>There are multiple ways to inspect changes to a file using the Git CLI. I will show you two examples using <code>git log</code>.</p> <p>Show all commits that have made changes to a specific file:</p> <p><code>git log --follow &lt;filename&gt;</code></p> <pre><code>git log --follow docs/commits/committing.md\n</code></pre> <p>Terminal output (truncated):</p> <pre><code>commit 90881e6ef792aa3351d9bbf5191f7b8cb314251a\nAuthor: Laurens van der Tas &lt;Laurens@email.nl&gt;\nDate:   Mon Feb 27 13:49:03 2023 +0100\nChange: Cleanup from proof reading\ncommit c9df343a6121d5573c1ce545113ddc82686362d3\nAuthor: Laurens van der Tas &lt;Laurens@email.nl&gt;\nDate:   Wed Feb 22 12:42:41 2023 +0100\nChange: Fixes and expansion commits section\ncommit 0db34a8d2f207fcf61539a2f8d13c4e0278385d7\nAuthor: Laurens van der Tas &lt;Laurens@email.nl&gt;\nDate:   Wed Feb 22 11:46:07 2023 +0100\n</code></pre> <p>Show detailed changes that have been made to a file by commit:</p> <p><code>git log -p &lt;filename&gt;</code></p> <pre><code>git log -p docs/commits/committing.md\n</code></pre> <p>Terminal output (truncated):</p> <pre><code>commit 90881e6ef792aa3351d9bbf5191f7b8cb314251a\nAuthor: Laurens van der Tas &lt;Laurens@email.nl&gt;\nDate:   Mon Feb 27 13:49:03 2023 +0100\nChange: Cleanup from proof reading\ndiff --git a/docs/commits/committing.md b/docs/commits/committing.md\nindex 086ea1a..1fc2263 100644\n--- a/docs/commits/committing.md\n+++ b/docs/commits/committing.md\n@@ -17,4 +17,6 @@ Upon running this, you will get a message like the following:\n```\n!!! info\n-    I have now created a commit (i.e. 'save point') for these two files in their current state. I have included them both in a single commit, because that makes sense here; both files are part of the content section about commits in my project.\n:...skipping...\n</code></pre>"},{"location":"commits/staging.html","title":"Staging","text":"<p>Before you can commit a file (or files), you first have to stage them. You can do this using the <code>git add</code> command.</p>"},{"location":"commits/staging.html#staging-files","title":"Staging files","text":"<p>First, an example of my current status, using <code>git status</code>:</p> <pre><code>On branch development\nChanges not staged for commit:\n(use \"git add &lt;file&gt;...\" to update what will be committed)\n(use \"git restore &lt;file&gt;...\" to discard changes in working directory)\nmodified:   docs/commits/index.md\nmodified:   docs/git_repository/status.md\nmodified:   mkdocs.yml\nUntracked files:\n(use \"git add &lt;file&gt;...\" to include in what will be committed)\ndocs/commits/committing.md\ndocs/commits/staging.md\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n</code></pre> <p>Let's say I want to include both untracked files so I can preserve them in a single commit. To do that, I would run the following:</p> <pre><code># Add new files to staging area\ngit add docs/commits/committing.md\ngit add docs/commits/staging.md\n</code></pre>"},{"location":"commits/staging.html#verifying","title":"Verifying","text":"<p>If I were to run <code>git status</code> once more, the following shows up:</p> <pre><code>On branch development\nChanges to be committed:\n(use \"git restore --staged &lt;file&gt;...\" to unstage)\nnew file:   docs/commits/committing.md\nnew file:   docs/commits/staging.md\nChanges not staged for commit:\n(use \"git add &lt;file&gt;...\" to update what will be committed)\n(use \"git restore &lt;file&gt;...\" to discard changes in working directory)\nmodified:   docs/commits/index.md\nmodified:   docs/git_repository/status.md\nmodified:   mkdocs.yml\n</code></pre> <p>The new Markdown files are now ready to be committed, which we'll cover in the next section.</p>"},{"location":"design_best_practices/index.html","title":"Design &amp; Best Practices","text":"<p>When it comes to creating and organising your repository into branches, and deciding on when and how to commit, there are a couple of best practices to consider. I will list some of them in this section.</p> <p>However, this is by no means an exhaustive list, so feel free to search for additional information online. Eventually, you will find a method which works best for you. Above all, it is important to remember to maintain consistency in your approach to avoid confusion for co-contributors.</p>"},{"location":"design_best_practices/best_practices.html","title":"Best Practices","text":"<p>Here, I will list some best practices you should consider.</p>"},{"location":"design_best_practices/best_practices.html#when-to-commit","title":"When to commit?","text":"<p>Commit often, perfect later, publish once.</p> <p>Git only starts taking responsibility for your data after you have committed it for the first time.</p> <p>Remember that time when had just written that fancy class, and had started adding all kinds of spectacular methods to it, only to find out further down the line that somewhere, something, broke it entirely?</p> <p>That is why you commit often:</p> <ul> <li>Finished writing the most basic structure of that class and its constructor method? Commit it!</li> <li>Finished writing those dynamic property decorators for it? Commit it!</li> <li>Halfway done implementing that fancy new method for it? Commit it!</li> </ul> <p>Having all these checkpoints in the form of commits means you can revert to it when something breaks and, more importantly, help you understand how it broke in the first place.</p> <p>After everything works, and you find your cascade of commits to be a bit much, you can always condense your commit history by squashing some commits, using an interactive rebase.</p>"},{"location":"design_best_practices/best_practices.html#how-to-structure-commit-messages","title":"How to structure commit messages?","text":"<p>Be clear and consistent in your commit message structure.</p> <ul> <li>Use prefixes, such as e.g. Add, Delete, Change:<ul> <li>Add: SQL feeds</li> <li>Change: Data ingression</li> <li>Delete: Todo Markdown file</li> </ul> </li> </ul> <p>Some employers, and most serious open-source projects, likely require a strict commit message structure to adhere to. Make sure you carefully read up on it, before blithely filing a pull request full of commits with janky commit messages.</p>"},{"location":"design_best_practices/best_practices.html#when-to-create-new-branches","title":"When to create new branches?","text":"<p>Branch early and branch often.</p> <p>First and foremost, when you initialise a new repository, create a <code>development</code> branch as soon as possible. Just create and commit a <code>.gitignore</code> file into your <code>main</code> branch, then create your <code>development</code> branch and just work in that, until you get an idea on where you want to go. Keep <code>main</code> as stable as you can.</p> <ul> <li>Are you starting work on a new feature? Create a new branch for it!</li> <li>Are you improving upon an existing feature that already works well in its current state? Create a new branch for it!</li> <li>Are you just trying out something new in an existing codebase? Create a new branch for it!</li> </ul> <p>You get the picture. Adhering to this workflow will save you the hassle of constantly needing to rewrite the history of your repository further down the line. Also, it makes your repository look a lot more structured and professional.</p>"},{"location":"design_best_practices/best_practices.html#when-to-delete-branches","title":"When to delete branches?","text":"<p>Delete branches when their purpose has been served and the changes have been merged.</p> <p>This will make your repository a lot easier to work with for everybody involved. Stale and unused branches clutter your repository and cause a lot of confusion.</p> <p>If you want to leave a marker to denote when the branch was incorporated into your <code>development</code> branch, or <code>main</code> branch, create a <code>tag</code> at the merge commit instead of leaving a finalised branch dangling.</p>"},{"location":"design_best_practices/best_practices.html#how-to-name-branches","title":"How to name branches?","text":"<p>Be clear and consistent when naming your branches.</p> <ul> <li>The default branch is always called <code>main</code> (<code>master</code> in older Git versions).</li> <li>Be logical and intuitive when naming additional branches.<ul> <li>A <code>development</code> branch is an obvious branch to create as soon as possible.</li> <li>When creating feature branches, use clear names, such as <code>f_preprocessing</code>, or better yet: <code>feature/preprocessing</code>.</li> </ul> </li> </ul>"},{"location":"design_best_practices/design.html","title":"Design","text":"<p>The design pattern I often use, borrows ideas of both the Flow and Trunk paradigms, as shown in the visualisation below. Moreover, further down below, I have included a clarification on what purpose each branch serves.</p> <pre><code>gitGraph\n  commit id: \"M_1\" tag: \"v0.1\"\n  branch development\n  commit id: \"D_1\"\n  checkout main\n  merge development\n  commit id: \"M_2\" tag: \"v0.2\"\n  branch hotfix\n  commit id: \"H_1\"\n  commit id: \"H_2\"\n  checkout main\n  merge hotfix\n  checkout development\n  merge hotfix\n  checkout development\n  branch feature/api\n  commit id: \"A_1\"\n  checkout development\n  branch feature/algorithm\n  commit id: \"AG_1\"\n  commit id: \"AG_2\"\n  checkout development\n  merge feature/algorithm\n  commit id: \"D_2\"\n  checkout feature/api\n  commit id: \"A_2\"\n  commit id: \"A_3\"\n  checkout main\n  merge development\n  commit id: \"C\" tag: \"v1.0\"</code></pre> <p>While this may be a little bit convoluted for very small projects, where you can get away with a <code>main</code> and <code>development</code> branch, it is great to use in somewhat larger projects with multiple contributors.</p>"},{"location":"design_best_practices/design.html#branch-main","title":"Branch: <code>main</code>","text":"<p>This should be the release branch. Only stable, production-grade code should reside here. The only branches that should merge into the <code>main</code> branch are the <code>development</code> and <code>hotfix</code> branches. </p> <ul> <li>The <code>development</code> branch merges into <code>main</code> when a new release, with new features, has been completed, tested, and is ready for the end user.</li> <li>The <code>hotfix</code> branch merges into <code>main</code> to patch showstopping bugs or issues, if they occur.</li> </ul>"},{"location":"design_best_practices/design.html#branch-development","title":"Branch: <code>development</code>","text":"<p>This should be the experimental branch. It incorporates new features that have been merged from feature branches. Furthermore, it is used for very minor development work on existing features that do not merit the creation of a new branch. The only branches that should merge into the <code>development</code> branch are <code>feature</code> branches and the <code>hotfix</code> branch.</p> <ul> <li>The <code>feature</code> branches merge into <code>development</code> when a feature is considered complete and is ready for testing.</li> <li>The <code>hotfix</code> branch merges into <code>development</code> to incorporate patches for showstopping bugs or issues, should they occur on the live application on <code>main</code>.</li> </ul>"},{"location":"design_best_practices/design.html#branch-hotfix","title":"Branch: <code>hotfix</code>","text":"<p>This is an emergency branch that is created directly from the latest release on the <code>main</code> branch to address a showstopping bug or issue that might occur there.</p> <ul> <li>The branch is deleted immediately after the changes have been merged into <code>main</code> and <code>development</code>.</li> <li>Nothing should merge into the <code>hotfix</code> branch.</li> </ul>"},{"location":"design_best_practices/design.html#branch-feature","title":"Branch: <code>feature</code>","text":"<p>These are branches that introduce entirely new features to the codebase, or revise/improve upon existing functionality.</p> <ul> <li>These branches merge into the <code>development</code> branch, and are deleted after the final feature, or improvements, have been completed.</li> </ul>"},{"location":"design_best_practices/tools.html","title":"Tools &amp; Extensions","text":"<p>You can, of course, perform your entire Git workflow using the Git CLI in your Terminal. In fact, I heavily recommend at least understanding, and performing, the basic Git workflow using the CLI at least once. This will help you build some familiarity and muscle memory.</p> <p>I still use the CLI for some Git operations on a daily basis. A prime example is interactive rebasing. The CLI provides a fine-grained amount of control that most tools and extensions with a UI do not provide. </p> <p>Nevertheless, manually staging every single change, and constantly consulting your <code>git log</code> and <code>git reflog</code> in the CLI can be tedious and exhausting. Luckily, there are tools and extensions available that will make your life a lot easier. I will list some here.</p>"},{"location":"design_best_practices/tools.html#git-graph","title":"Git Graph","text":"<p>This extension is my very favourite and, in my opinion, an absolute must-have for everybody working with Git repositories using Visual Studio Code. </p> <p>It provides a tree-based visualisation of your entire repository. Furthermore, it provides options for easily checking out, creating branches, merging branches, cherry-picking, etc. from within the UI.</p> <p></p> <p></p>"},{"location":"design_best_practices/tools.html#gitlens","title":"GitLens","text":"<p>This extension is quite possibly capable of doing everything Git-related from within Visual Studio Code.</p> <p>Unfortunately, the full feature set is for paying users only, so I cannot comment on the full user experience. However, I am quite sure this extension would enable you to forget about the Git CLI entirely and handle every operation through the extension's UI instead.</p>"},{"location":"design_best_practices/tools.html#github-pull-requests-and-issues","title":"GitHub Pull Requests and Issues","text":"<p>This extension provides an interface to manage issues and pull requests from within Visual Studio Code.</p> <p></p>"},{"location":"git_repository/index.html","title":"The Git Repository","text":"<p>A <code>repository</code> is a specific folder that you have instructed Git to track.</p>"},{"location":"git_repository/index.html#initializing-a-repository","title":"Initializing a repository","text":"<p>Before Git is able to track files, you first have to tell it to treat a specific directory as a repository. This is called initialising a repository and is done with the <code>git init</code> command.</p> <pre><code># Initialize a repository in your current working directory\ngit init\n</code></pre> <p>Basically, from here on out, every change you will make to a file within this working directory will be tracked by Git.</p>"},{"location":"git_repository/status.html","title":"Status","text":"<p>To get a quick bearing of your version control surroundings, you can use the <code>git status</code> command.</p> <pre><code>git status\n</code></pre> <p>This command will provide you with an overview of e.g. which files:</p> <ul> <li>Have been changed;</li> <li>Have been newly added;</li> <li>Have been deleted.</li> </ul> <p>Running the command will provide something in line with the following information:</p> <pre><code>On branch development\nChanges not staged for commit:\n(use \"git add &lt;file&gt;...\" to update what will be committed)\n(use \"git restore &lt;file&gt;...\" to discard changes in working directory)\nmodified:   docs/git_repository/status.md\nUntracked files:\n(use \"git add &lt;file&gt;...\" to include in what will be committed)\ndocs/git_repository/abu_bakr.md\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n</code></pre>"},{"location":"git_repository/working_staging_repo.html","title":"Working Directory, Staging Area &amp; Repository","text":"<p>Generally speaking, there are three components to Git's way of source code management.</p> <pre><code>graph LR\n  A(Working Directory) -.-&gt; |git add| B(Staging Area) -.-&gt; |git commit| C(Tracked)</code></pre>"},{"location":"git_repository/working_staging_repo.html#working-directory","title":"Working Directory","text":"<p>The current state of the files and folders in the filesystem. Initially, if you do not tell it to by committing, Git does not track files yet.</p>"},{"location":"git_repository/working_staging_repo.html#staging-area","title":"Staging Area","text":"<p>Before modified files can be 'saved' (i.e. committed) to the repository, they have to be <code>staged</code>.</p> <pre><code># Stage script.py\ngit add script.py\n</code></pre> <p>Info</p> <p>You can also stage multiple files and 'save' (i.e. submit them for tracking) within a single commit. This is especially useful if multiple files are associated with a change you would like to commit.</p>"},{"location":"git_repository/working_staging_repo.html#repository","title":"Repository","text":"<p>The repository, i.e. the working directory in which you have run <code>git init</code>, holds all your committed files and references. All this information is saved in the hidden <code>.git</code> folder.</p>"},{"location":"next_steps/index.html","title":"Next steps","text":"<p>Thanks for reading this guide, and well done! You have made it all the way through.</p> <p>In this section, I will list some options for those who would like to solidify their grasp on Git a little bit further.</p>"},{"location":"next_steps/tutorials_projects.html","title":"Tutorials &amp; Projects","text":"<p>A great way to bring the concepts covered in this guide into practice, and start building some muscle memory, is by completing the interactive tutorial of LearnGitBranching. </p> <p>You can more or less regard it as a practical exam to this guide. While not every scenario presented there is realistic, its aim is to familiarise you with the Git CLI and it does so very well. It starts off quite easy, but it gets a lot more challenging towards the end.</p> <p>After going through all the interactive exercises on that site, you will be proficient enough in Git to handle virtually all your version control needs.</p>"},{"location":"next_steps/tutorials_projects.html#actively-use-git","title":"Actively use Git","text":""},{"location":"next_steps/tutorials_projects.html#work-projects","title":"Work projects","text":"<p>Start using Git in all your programming projects at work. Even if the codebase may seem small, and using Git may seem trivial, use Git and adhere to the principles taught here (proper branching, committing, etc.).</p> <p>If you stick to this, the fundamental principles of Git will become second nature in no time. Furthermore, you never know if your small work project eventually ends up becoming some huge repeating data analysis, with new requests coming in constantly. Then, you would be glad you had been using Git from the get go.</p>"},{"location":"next_steps/tutorials_projects.html#private-projects","title":"Private projects","text":"<p>Also, if you work on any private projects, use Git in those as well and combine it with a service like GitHub. This will enable you to practice working with remote branches and pull requests.</p> <p>Apart from generic public repositories, I maintain a couple of private GitHub repositories with friends containing complex projects. These projects range from, e.g., Discord bots to web crawlers for Dutch real estate prices to investment portfolio management and optimization tools. When friends finish a feature in one of the repositories, they file a pull request, which I can then code review and eventually incorporate into the project.</p> <p>Aside from learning Git in a real-world environment, it is also a great way to improve each other's programming skills by learning from peers.</p>"},{"location":"next_steps/tutorials_projects.html#open-source-contribution","title":"Open-source contribution","text":"<p>You could also consider contributing to popular, large open-source projects in order to get more in-depth experience. </p> <p>There is always work to be done in open-source projects, and this does not necessarily mean NASA-level complex stuff, such as optimising some confusing low-level algorithm in C++ to reduce CPU wall time by some 10 nanoseconds. To get your feet wet, you could start contributing by fixing some docstrings, doing some basic refactoring for convoluted code, or adding proper typing to existing functions and methods to help users' type checking and IntelliSense.</p> <p>There are plenty of contributions to be made across all different degrees of coding skill, and every contribution is very valuable.</p>"},{"location":"remote_repos/index.html","title":"Remote Repositories","text":"<p>A lot of people are familiar with services like GitHub, GitLab or Azure DevOps Repositories, but do not know Git is the driving piece of software behind it. </p> <p>Actually, this is not that strange, because it are these well-known tools that enable large communities of developers to work on a project concurrently, whilst keeping track of all changes and releases in the grand scheme of things. Intuitively, the name Git has gained a top-of-mind association with these large tools, instead of the actual piece of software driving the tools: it has made coding social.</p> <p>This collaboration is achieved using remote repositories. These allow a developer to locally develop, but synchronise all changes with a remote single point of truth, which is accessed and shared by all developers working on the repository.</p>"},{"location":"remote_repos/clone_fork.html","title":"Clone &amp; Fork","text":"<p>When starting collaboration on an existing project, you need a way to tell Git where the remote repository you want to collaborate on resides, and you need to get a local copy of said codebase to work on for yourself. There are two ways to do this: cloning the repository, or forking the repository.</p>"},{"location":"remote_repos/clone_fork.html#cloning","title":"Cloning","text":"<p>The <code>git clone</code> command is perhaps the most well-known. This command allows you to reflect (i.e. make a copy) the repository, in its current state, locally. Moreover, this automatically registers this source repository as the remote repository within Git. This will enable you to <code>git fetch</code> commits and branches (retrieve changes made by others) from the remote repository, and <code>git push</code> (submit your own changes and branches) to this remote repository.</p> <p>For example, I frequently contribute to open-source development projects, such as PyTorch: a popular deep learning framework. If you would want to do that as well, you would start by cloning the repository:</p> <pre><code># Navigate to the directory you want to store the cloned repository\ncd ~/coding/python\n\n# Clone the Pytorch repository\ngit clone https://github.com/pytorch/pytorch\n\n# Change directory to the repository\ncd pytorch\n</code></pre> <p>As visualised below, this workflow enables multiple developers to work on the same project (repository) at the same time.</p> <pre><code>flowchart TB\n  R[(Remote&lt;br /&gt;Repository)] &lt;-. Push/Pull .-&gt; C_1(&lt;b&gt;Clone&lt;/b&gt;&lt;br/&gt;Developer 1)\n  R &lt;-. Push/Pull .-&gt; C_2(&lt;b&gt;Clone&lt;/b&gt;&lt;br/&gt;Developer 2)\n  R &lt;-. Push/Pull .-&gt; C_3(&lt;b&gt;Clone&lt;/b&gt;&lt;br/&gt;Developer 3)</code></pre>"},{"location":"remote_repos/clone_fork.html#forking","title":"Forking","text":"<p>Forking a repository is a similar concept to cloning, but there a some differences.</p> <p>When using <code>git clone</code>, you copy the entire repository, along with its ties to the remote location, thus enabling you to <code>git fetch</code> from it and <code>git push</code> to it. A fork only copies the repository, but creates an entirely new and separated codebase. There is no synchronisation between your fork and the original repository, in the sense that you could push to it, or pull from it, as you would have been able to when cloning. In Git terms: It does not register the source as a remote repository for your local repository.</p> <pre><code>flowchart TD\n  R[(Project&lt;br /&gt;Repository)] &lt;-. Push/Pull ..-&gt; C_1(&lt;b&gt;Clone&lt;/b&gt;&lt;br/&gt;Developer 1)\n  R &lt;-. Push/Pull ..-&gt; C_2(&lt;b&gt;Clone&lt;/b&gt;&lt;br/&gt;Developer 2)\n  R &lt;-. Push/Pull ..-&gt; C_3(&lt;b&gt;Clone&lt;/b&gt;&lt;br/&gt;Developer 3)\n  R -- Fork --&gt; F[(Forked&lt;br/&gt;Repository)]\n  F &lt;-. Push/Pull .-&gt; C_4(&lt;b&gt;Clone&lt;/b&gt;&lt;br/&gt;Developer 4)</code></pre> <p>A fork allows you to essentially 'stand on the shoulders of giants'; i.e. you can use an existing codebase as a foundation, but adapt the project to go in an entirely different direction. For example, the MariaDB database application started as a fork from the well-known MySQL database application.</p> <p>Note</p> <p>Fork is not a command available within Git itself. You can access forking as a feature of services like GitHub, or GitLab. The reason why it is not a feature of the Git CLI is beyond the scope of this document.</p>"},{"location":"remote_repos/fetch_pull_push.html","title":"Fetch, Pull &amp; Push","text":"<p>In order te retrieve changes made by others, and submit your own changes to the remote, you can use the <code>git fetch</code>, <code>git pull</code> and <code>git push</code> commands.</p>"},{"location":"remote_repos/fetch_pull_push.html#fetching-changes","title":"Fetching changes","text":"<p>The <code>git fetch</code> command downloads all commits, files and refs from a remote repository into your local repository. Fetched content will not be immediately merged, but will remain isolated from existing local content, which makes it safe. You can review all fetched commits before merging them with your existing work.</p>"},{"location":"remote_repos/fetch_pull_push.html#example-git-fetch","title":"Example: <code>git fetch</code>","text":"<p>The following example only performs a <code>git fetch</code>. Hence, it does not automatically merge the fetched content. This needs to be done manually by merging the <code>origin/development</code> branch, using <code>git merge</code>.</p> <p>After performing <code>git fetch</code>, the remote-tracking branches will be in sync with the remote. However, your regular branches do not yet reflect the changes, until we merge them.</p> <pre><code># Fetch all changes across all branches from remote origin\ngit fetch origin\n\n# Fetch changes from a specific branch from remote origin\ngit fetch origin development\n\n# Fetch all changes across branches from across all remotes\ngit fetch --all\n</code></pre>"},{"location":"remote_repos/fetch_pull_push.html#example-git-fetch-with-git-merge","title":"Example: <code>git fetch</code> with <code>git merge</code>","text":"<p>The following example performs a <code>git fetch</code> and then merges the fetched content with <code>git merge</code>. The changes on the remote are now fully incorporated in your local repository. Both the remote-tracking branches and the regular branches are up-to-date.</p> <pre><code># Fetch the changes from the 'development' branch on remote 'origin',\n# which are then stored in 'origin/development' locally\ngit fetch origin development\n\n# Checkout local 'development' branch\ngit switch development\n\n# Merge the changes from 'origin/development' into 'development'\ngit merge origin/development\n</code></pre>"},{"location":"remote_repos/fetch_pull_push.html#pulling-changes","title":"Pulling changes","text":"<p>The <code>git pull</code> command is more assertive. Not only will it download (<code>git fetch</code>) all changes from the remote repository, it will also immediately call <code>git merge</code> to integrate it. </p> <p>If you already have pending changes, this may cause merge conflicts, which you need to resolve, in order for the pull to go through successfully. Merge conflicts will be covered in a later section.</p>"},{"location":"remote_repos/fetch_pull_push.html#example-git-pull","title":"Example: <code>git pull</code>","text":"<pre><code># Checkout local 'development' branch\ngit switch development\n\n# Fetch remote's state of current branch and merge it into local\ngit pull\n</code></pre>"},{"location":"remote_repos/fetch_pull_push.html#example-git-pull-using-git-rebase","title":"Example: <code>git pull</code> using <code>git rebase</code>","text":"<p>For those who prefer rebasing to merging, <code>git pull --rebase</code> uses <code>git rebase</code> instead of <code>git merge</code> when integrating the fetched changes into the local active branch.</p> <pre><code># Checkout local 'development' branch\ngit switch development\n\n# Fetch remote's state of current branch and rebase it onto local\ngit pull --rebase\n</code></pre>"},{"location":"remote_repos/fetch_pull_push.html#pushing-changes","title":"Pushing changes","text":"<p>The <code>git push</code> command submits your changes in the local repository to the remote repository. It is the exact counterpart of <code>git fetch</code>.</p>"},{"location":"remote_repos/fetch_pull_push.html#example-git-push","title":"Example: <code>git push</code>","text":"<pre><code># Push the current checked out branch to remote\ngit push\n\n# Push commits in local 'development' branch to remote 'origin'\ngit push origin development\n\n# Push commits across all local branches to remote 'origin'\ngit push origin --all\n</code></pre>"},{"location":"remote_repos/merge_conflicts.html","title":"Merge conflicts","text":"<p>Git is built with managing contributions from multiple developers on a single codebase in mind. In this way of working, it could happen that developers are editing, and committing, changes on the same files at the same time. When this occurs, a conflict may arise upon merging the changes.</p> <p>The observant reader will probably think: \"we can prevent that using separate, isolated branches, right?\". This certainly does prevent some conflicts that could arise. However, it may still happen that, when merging branches from separate developers, merge conflicts arise nonetheless.</p>"},{"location":"remote_repos/merge_conflicts.html#understanding-merge-conflicts","title":"Understanding merge conflicts","text":"<p>Upon the occurrence of a merge conflict, Git is unable to automatically determine the correct state of the file. Git only communicates this to the developer conducting the merge (i.e. the unlucky person running <code>git merge</code>). </p> <p>Once a merge conflict has been detected by Git, it will mark the file as conflicted and halt the merging process. The developer can then resolve the merge conflict by indicating to Git which changes are correct, and should be merged, and which changes can be left out of the merge and discarded.</p> <p>Some cases where merge conflicts can occur:</p> <ul> <li>When multiple developers have changed the same lines of code in a file, and then try to merge their work.</li> <li>When a developer deletes a file, even though another developer was working on altering it.</li> </ul> <p>A case where Git will simply not start the merge, and marks it as a conflict, is when the working directory is not clean:</p> <ul> <li>When there are pending changes in the staging area, which still have to be committed.</li> <li>When there are detected changes in your files, which you first have to stage and then commit.</li> </ul> <p>Tip</p> <p>If you are unsure how to resolve a merge conflict, run <code>git merge --abort</code>. This will immediately exit you from the merge and will return the branch to the state it was in before you initiated the merge.</p> <p>Now you have some breathing room to do some more research, or ask a more experienced colleague for help.</p>"},{"location":"remote_repos/merge_conflicts.html#examples","title":"Examples","text":"<p>The images below show how a merge conflict may be handled in Visual Studio Code.</p>"},{"location":"remote_repos/merge_conflicts.html#arising-merge-conflict","title":"Arising merge conflict","text":"<p>A merge conflict has occurred in one file. Both versions of the files, along with the conflicting lines, are shown.</p> <p></p>"},{"location":"remote_repos/merge_conflicts.html#possible-solutions","title":"Possible solutions","text":"<p>To resolve a merge conflict, the developer has a couple of options at their disposal.</p>"},{"location":"remote_repos/merge_conflicts.html#accept-current-state","title":"Accept current state","text":"<p>By accepting the current state, the incoming changes are dropped. The results are shown in the bottom panel in the UI.</p> <p></p>"},{"location":"remote_repos/merge_conflicts.html#accept-incoming-state","title":"Accept incoming state","text":"<p>By accepting the incoming state, the current changes are dropped. The results are shown in the bottom panel in the UI.</p> <p></p>"},{"location":"remote_repos/merge_conflicts.html#accept-both-states","title":"Accept both states","text":"<p>By accepting both states, the changes of both states are squeezed together. Carefully check the result when considering this option. In the example below, it is shown that accepting both states will result in syntactically invalid JSON, and will therefore break our code.</p> <p></p>"},{"location":"remote_repos/merge_conflicts.html#accept-a-solution","title":"Accept a solution","text":"<p>After selecting your resolution (in this example: accept incoming changes), and hitting the Confirm Merge button, the merge conflict will have been resolved. You can now commit your changes.</p> <p></p>"},{"location":"remote_repos/pull_requests.html","title":"Pull Requests","text":"<p>In order to manage the code quality of contributions in remote (public) repositories, such as on GitHub, GitLab or Azure DevOps, not everybody is simply allowed to push and merge changes in whatever branch they see fit to. This is where a PR (pull request) comes in.</p> <p>In their most basic form, pull requests are a mechanism for the developer to notify co-developers that they have completed a contribution, and they would like to have it integrated in the (public) remote repository. Once their contribution is ready, the developer creates a pull request, which notifies the repository's maintainer there is a contribution ready for review. The repository's maintainer can then review the code, ask questions, suggest changes, and/or allow for the changes to be merged.</p> <p>However, a pull request is more than this. It also provides a space to discuss the feature, or any issues with it, at length. Furthermore, the changes made within the pull request can even be altered and improved upon by follow-up commits, within the pull request itself, before allowing it to be merged into the repository.</p> <p>Note</p> <p>The Git CLI does have the <code>git request-pull</code> command. Generally, pull requests are created from within the service where the remote repository is hosted, for instance on GitHub. This provides a lot more flexibility.</p> <p>There are many options for creating pull requests on such platforms, without interfacing with the website (i.e. from your CLI or IDE), however that is beyond the scope of this document.</p> Protected <code>main</code> branches <p>Often, public repositories have a protected <code>main</code> branch, or multiple protected branches. This ensures the <code>main</code> branch can never be directly committed in, or pushed to. Trying to do so, will yield an error. This is done to ensure a bug-free and stable release branch.</p> <p>The only way to get your changes incorporated into these protected branch is via a pull request.</p>"},{"location":"remote_repos/remote_branches.html","title":"Remote Branches","text":"<p>When working with remote repositories, you get so-called remote-tracking branches. Remote-tracking branches are references to the state of remote branches. The names of these branches take the form of <code>&lt;remote&gt;/&lt;branch&gt;</code>, e.g. <code>origin/development</code>. </p> <p>You cannot directly manipulate these branches yourself. Git will automatically do this whenever any network communication occurs, in order to make sure they accurately represent the state of the remote repository.</p> <p>Info</p> <p>Think of remote-tracking branches as bookmarks: they remind you what the branches in your remote repositories contained the last time you connected to them.</p> <p>Visual example of remote-tracking branches in a repository:</p> <p></p>"},{"location":"remote_repos/remote_branches.html#manipulating-remotes","title":"Manipulating Remotes","text":"<p>When you clone a repository, using <code>git clone</code>, Git will automatically register the location of the remote. However, you can also manually add or remove remotes:</p> <pre><code># Initialise an empty repository for illustration purposes\ngit init\n\n# Manually add a remote 'origin' for the current repository\ngit remote add origin git@ssh.dev.azure.com:v3/organisation/subdomain/Placeholder\n\n# Manually remove remote 'origin' for the current repository\ngit remote rm origin\n</code></pre>"},{"location":"remote_repos/remote_branches.html#example","title":"Example","text":"<p>Consider the example below:</p> <ul> <li><code>origin/main</code>: Remote-tracking branch of remote <code>main</code> branch.</li> <li><code>origin/feature/algorithm</code>: Remote-tracking branch of remote <code>feature/algorithm</code> branch.</li> <li><code>main</code>: Local state of <code>main</code> branch.</li> <li><code>feature/api</code>: Local state of <code>feature/api</code> branch.</li> </ul> <pre><code>%%{init: { 'logLevel': 'debug', 'theme': 'base', 'gitGraph': {'showBranches': true, 'showCommitLabel': false, 'mainBranchName': 'origin/main'}} }%%\ngitGraph\n  commit tag: \"0\"\n  branch main order: 2\n  commit tag: \"1\"\n  commit tag: \"2\"\n  branch feature/api order: 3\n  commit tag: \"3\"\n  checkout origin/main\n  commit tag: \"4\"\n  branch origin/feature/algorithm order: 1\n  commit tag: \"5\"\n  checkout origin/main\n  commit tag: \"6\"</code></pre> <p>The following has happened here:</p> <ol> <li>The repository is cloned locally from the remote state at commit tag <code>0</code>.</li> <li>Commit tag <code>1</code> &amp; <code>2</code>:<ul> <li>Two commits are made in <code>main</code> (local).</li> </ul> </li> <li>Commit tag <code>3</code>:<ul> <li>A new branch <code>feature_api</code> is made from <code>main</code> and a commit is made to it (local).</li> </ul> </li> <li>Commit tag <code>4</code>:<ul> <li>A collaborating developer has pushed a commit to the remote <code>main</code> branch, reflected in remote-tracking branch <code>origin/main</code>.</li> </ul> </li> <li>Commit tag <code>5</code>:<ul> <li>A collaborating developer pushed a new remote branch <code>feature/algorithm</code> (branched from <code>main</code>) with a commit in it, as reflected in remote-tracking branch <code>origin/feature/algorithm</code>.</li> </ul> </li> <li>Commit tag <code>6</code>:<ul> <li>A collaborating developer pushed another commit to the remote <code>main</code> branch, reflected in remote-tracking branch <code>origin/main</code>.</li> </ul> </li> </ol> <p>Note</p> <p>Note that we do not physically have the changes in the remote repository, as made by the collaborating developers, reflected in our local repository until we explicitly retrieve them. This retrieval can be accomplished using <code>git fetch</code>. After running this command, the remote-tracking branches will be updated with the latest changes from the remote.</p> <p>Fetching and pushing changes will be covered in the next section.</p>"},{"location":"revert_reset/index.html","title":"Rewriting history","text":"<p>It may happen that you make a mistake in a commit and want to undo this. There are several ways to go about this, but I will discuss <code>git revert</code> and <code>git reset</code> here.</p>"},{"location":"revert_reset/head.html","title":"The HEAD state","text":"<p>In Git, <code>HEAD</code> is a pointer that refers to the current state of the commit, or branch, that you are checking out. This means that the filesystem reflects the reality as per that commit/branch.</p> <ul> <li>If you check out a branch, your <code>HEAD</code> state will refer to the current state of that branch.</li> <li>If you check out a specific commit, your <code>HEAD</code> state will refer to the current state of that commit.</li> </ul> <p>Simply put, checking out different branches, or commits, will physically change the files you see in the repository, along with their content. That is the <code>HEAD</code> pointer in action.</p> <p>Info</p> <p>Checking out a commit instead of a branch will lead to a so called detached HEAD state.</p>"},{"location":"revert_reset/head.html#relative-referencing","title":"Relative Referencing","text":"<p>In the command <code>git reset --hard HEAD~</code>, you will have noticed the <code>~</code> part. The <code>~</code> operator follows the first parent of a merge commit back in time. In the example of the reset command, this translates to simply 'go back one commit from the current <code>HEAD</code> state'. </p> <p>With respect to the basic relative ref operators:</p> <ul> <li><code>~&lt;n&gt;</code><ul> <li>The <code>~</code> operator follows the first parent of a merge commit <code>&lt;n&gt;</code> number of commits back in time.</li> <li><code>HEAD~3</code> will refer to the commit located three commits before the <code>HEAD</code> state.</li> </ul> </li> <li><code>^&lt;n&gt;</code><ul> <li>The <code>^</code> operator follows the parent of a merge commit, specified by number <code>&lt;n&gt;</code> denoting the parent, back in time.</li> <li><code>HEAD^2</code> will refer to the second parent of the merge commit, if <code>HEAD</code> is a merge commit.</li> <li>If <code>HEAD</code> is a regular commit, <code>HEAD^</code> will refer to the commit before <code>HEAD</code>; <code>HEAD^^</code> will refer to the commit before that, etc.</li> </ul> </li> </ul> Why use relative refs? <p>Relative refs are useful for traversing your commit history, without the need to provide the full commit hash.</p> <p>In Git, you refer to a commit by its hash, which can get very long (example: <code>eba3d714d77f49bae6a80864b13e0dfcc8a06608</code>). You can specify a partial hash and Git will usually be smart enough to figure out which commit you refer to (example: <code>eba3d</code>).</p> <p>However, it can be easier to refer to the commit you want by using the relative refs with respect to another commit, branch, or the HEAD state. This way, you do not need to look up and copy the hashes.</p>"},{"location":"revert_reset/head.html#example-relative-refs","title":"Example: Relative refs","text":"<p>The following example, borrowed from Atlassian, illustrates this visually. The notation above each commit shows how to reach it, using relative refs, from starting point <code>A</code>.</p> <p></p>"},{"location":"revert_reset/revert_reset.html","title":"Revert &amp; reset","text":""},{"location":"revert_reset/revert_reset.html#revert","title":"Revert","text":"<p><code>git revert</code> is the friendly way of undoing a commit and, frankly, the only acceptable way to do it, if you are working in remote repositories with a lot of contributors.</p> <p><code>git revert</code> adds a new commit that will undo the changes of the commit you want revoked. For example, if an unwanted commit adds the text \"Oops, my cat is walking over my keywalrhlgk\" to the bottom of a specific file, a revert on that commit will remove \"Oops, my cat is walking over my keywalrhlgk\" from the bottom of that file. It will effectively restore it to the state before that commit had been made.</p> <p>The great thing is that both your mistake, and the correction of said mistake, are preserved in your history. Thus, making it fully non-destructive.</p>"},{"location":"revert_reset/revert_reset.html#example-git-revert","title":"Example: <code>git revert</code>","text":"<p>We have accidentally committed a change in the <code>development</code> branch with commit hash <code>damn</code>. We want to use <code>git revert</code> to undo this change.</p> <pre><code># Ensure we are checked out in the right branch\ngit switch development\n\n# Revert the unwanted commit\ngit revert damn\n</code></pre> <pre><code>gitGraph\n  commit id: \"A\"\n  commit id: \"B\"\n  branch development\n  checkout main\n  commit id: \"C\"\n  commit id: \"D\"\n  checkout development\n  commit id: \"I\"\n  commit type: REVERSE id: \"damn\"\n  commit id: \"II\"\n  commit type: HIGHLIGHT id: \"undo_damn\"</code></pre> <p>The commit with hash <code>undo_damn</code> has now removed the changes made by commit <code>damn</code>.</p>"},{"location":"revert_reset/revert_reset.html#reset","title":"Reset","text":"<p><code>git reset</code> will move a branch to a commit back in time, in the sense that it appears as if the commit had never been made in the first place.</p> <pre><code># Checkout the branch that has the commit we want to reset\ngit switch development\n\n# Reset the branch, discarding the current commit\ngit reset HEAD\n\n# Reset the branch, discarding the last three commits\ngit reset HEAD~3\n</code></pre> <p><code>git reset</code> is also a way to clear changes that have been staged pending a commit, using <code>git add</code>. Consider the following example:</p> <pre><code># Let's stage two arbitrary files\ngit add script.py\ngit add README.md\n\n# If we would want to unstage README.md\ngit reset README.md\n\n# Or if we would want to unstage all files\ngit reset\n</code></pre> <p>However, the command can also be modified using the <code>--hard</code> flag. This way, the command can be used to hard delete commits. Commits reset this way will be entirely removed from the commit history - and file history - and cannot be retrieved. It is therefore fully destructive.</p>"},{"location":"revert_reset/revert_reset.html#example-git-reset-hard","title":"Example: <code>git reset --hard</code>","text":"<p>We have accidentally committed a change in the <code>development</code> branch with commit hash <code>damn</code>. We want to use <code>git reset --hard</code> to completely obliterate this mistake from the annals of history.</p> <pre><code>gitGraph\n  commit id: \"A\"\n  commit id: \"B\"\n  branch development\n  checkout main\n  commit id: \"C\"\n  checkout development\n  commit id: \"I\"\n  commit type: REVERSE id: \"damn\"\n  checkout main\n  commit id: \"D\"</code></pre> <pre><code># Ensure we are checked out in the proper branch\ngit switch development\n\n# Hard reset the branch one commit back from the current checked-out state\ngit reset --hard HEAD~\n</code></pre> <p>This will result in the following commit history:</p> <pre><code>gitGraph\n  commit id: \"A\"\n  commit id: \"B\"\n  branch development\n  checkout main\n  commit id: \"C\"\n  checkout development\n  commit id: \"I\"\n  checkout main\n  commit id: \"D\"</code></pre> <code>git reset</code> parameters: <code>--soft</code>, <code>--mixed</code>, <code>--hard</code> <ul> <li><code>git reset --soft</code>: Keeps files intact and moves the changes back to the staging area.</li> <li><code>git reset --mixed</code>: The default option, if you do not specify one explicitly. Keeps files intact, but removes them from the staging area.</li> <li><code>git reset --hard</code>: Completely eradicates changes and removes them from the repository, and local filesystem, entirely.</li> </ul>"},{"location":"stash/index.html","title":"Stash","text":"<p>When would you use <code>git stash</code>?</p> <ul> <li>Imagine you quickly need to change context within the repository, because a colleague asks for help, but the code changes you are currently working on are not yet ready to commit.<ul> <li>Stash them! This removes them from your pending changes, and allows you to help your colleague. Afterwards, you can retrieve your work from the stash and continue.</li> </ul> </li> <li>Imagine you want to commit changes for a feature you have been working on, but the upstream branch of this feature has been updated by a colleague. <ul> <li>Stash them! This removes them from your pending changes, allowing you to fetch and merge the upstream changes. Afterwards, you can retrieve your work from the stash and carry on.</li> </ul> </li> </ul>"},{"location":"stash/index.html#example-git-stash","title":"Example: <code>git stash</code>","text":"<pre><code># Stage some arbitrary changes in the INDEX\ngit add script.py\ngit add __init__.py\ngit add LICENSE\n\n# Stash the changes\ngit stash\n\n# Create the new branch and check it out\ngit branch feature/awesome\ngit checkout feature/awesome\n\n# List all stashes to find index number associated with your stash\ngit stash list\n\n# Apply the stash to the branch\ngit stash apply 0\n# Commit the changes\ngit commit -m \"From stash\"\n# Clean up the stash\ngit stash drop 0\n</code></pre> <p>I hacked together the visualisation below to give you some visual representation of what is going on. It is not entirely accurate, because Mermaid graphs do not support <code>git stash</code>, but it conveys the general idea.</p> <pre><code>gitGraph\n  commit id: \"A\"\n  commit type: REVERSE id: \"B\"\n  commit type: REVERSE id: \"C\"\n  branch stash\n  cherry-pick id: \"B\"\n  cherry-pick id: \"C\"\n  branch feature/awesome\n  commit type: HIGHLIGHT id: \"From stash\"</code></pre>"}]}